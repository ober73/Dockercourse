DOCKER COURSE

Multiple choice exams

2013
Docker used to use LXC

2014
but then docker introduced libcontainer


OCI

runtime-spec
image-spec

2016 things were broken down volumes images etc

and runC emerged to run containers

also containerd was introduced to manage the containers

then containerd-shim was created so that containers would continue to run even if the docker daemon stopped. It is detached. 

Docker manages 4 things

images, networks, containers, Volumes

INSTALL

docker system info  


docker daemon

dockerd --debug (for debugging)


when started it listens on rpc Unix Socket

/var/run/docker.sock (only can access on localhost)


we can open up the cli to outside by running the daemon like this

dockerd --debug \
        --hots=tcp://192.168.1.10:2375 (our host interface)
        
        
on the other host you can access docker by setting a variable

export DOCKER_HOST="tcp://192.168.1.10:2375"


you can enable encryption

dockerd --debug \
        --host=tcp://192.168.1.10:2376 \
        --tls=true
        --tlscert=/var/docker/server.pem \
        --tlskey=/var/docker/serverkey.pem
        
unencrypted 2375
encrypted 2376

you can move these settings to the docker daemon file

/etc/docker/daemon.json

{
  "debug": true,
  "hosts": ["tcp://192.168.1.10:2376"]
  "tls": true,
  "tlscert": "/var/docker/server.pem",
  "tlskey": "/var/docker/serverkey.pem"
}

docker container run -it ubuntu

docker image build .

docker container attach ubuntu

docker container kill ubuntu

docker container create httpd

container id has a short form as well


Stored in /var/lib/docker

containers in here

ls -lrt /var/lib/docker/containers/

ls -lrt /var/lib/docker/containers/36a391532e10*

Checkpoint hostconfig.json config.v2.json

docker container ls

docker container ls -a


docker container ls -l

docker container ls -q

docker container ls -aq

docker container start 36a391531e10

docker container run httpd

The ubuntu image runs then stops. What is the purpose of this?

To build other images on top of it.

docker container run -it ubuntu

i=interactive t=terminal

This will take us inside of the container

always add options before the container image name

to leave type exit


WE can add our own name

docker container run -itd --name=webapp ubuntu

To rename:
EX:
docker container rename webapp custom-webapp

By default container runs in attached mode


-d to detach mode


IF at some point later you want to re-attach to the container then run attach

EX:

docker container attach 11cb (use first digits of container id)

How to get ID's of running containers?

docker container ls -q


What flags are used to configure encryption on docker daemon

tlsverify, tlscert, tlskey
        
CTRL+p+q

puts container into detached mode

to run a command inside of the detached container
we can use exec

docker container exec b342fdsfwere <command>

or interactive again

docker contatiner exec -it b32432efasdfa /bin/bash

you can re-attach the container

docker container attach b71f1adswwerr


INSPECTING A CONTAINER

docker container inspect b7adfdasd


docker container stats (shows containers use of resources

or

docker container top <containername>


docker container logs 

docker system events --since 60m

LINUX SIGNALS

kill -SIGSTOP 13423

if you don't know the id you can replace with the pgrep command

kill -SIGSTOP $(pgrep htttpd)

SIGSTOP pauses the process 

to resume

kill -SIGCONT $(pgrep httpd)

to kill 

kill -SIGTERM polite way of asking process to stop

-SIGKILL is a force


each signal has a number as well

so

kill-9 


docker container pause

unpause

stop

docker uses freezer cgroup so that for certain containers will be paused or stops, i.e. they can't ignore like linux processes sometimes do.

You can kill processes inside the container by using the 

docker container kill --signal=9 web

REMOVE CONTAINER

stop container, then remove


docker container ls -q (lists only container id)

so you can add to commands

docker container stop $(docker container ls -q)

docker containter rm $(docker container ls -aq) use the a to show all containers even stopped ones

docker container prune (removes all stopped containers)

REMOVE FLAG

if we want the container to remove itself as soon as it has finihed its task

docker container run --rm ubuntu expr 4 + 5

docker container ls -l


/etc/lsb-release

docker container inspect

docker container top 52cweewrqer

docker container logs 25234324

docker container logs -f (shows realtime logs)

hostname is normally the beginning of the containerID

or set it

docker container run -it --name=webapp --hostname=webapp ubuntu

RESTART POLICY

if job completed then container will stop

docker container run ubuntu expr 3 + 5

Exited (0) code 0

or error (1) code 1

EX:

docker container run ubuntu expr three + 5

docker container run --restart= (this will auto restart

by default no

other settings on-failure, always, unless stopped

if you want your containers to continue working even if the docker daemon stops you can change the daemon properties

/etc/docker/daemon.json

{ 
  "debug": true,
  "host": ["tcp://192.168.1.10:2376"],
  "live-restore": true
}


COPYING FILES

docker container cp /tmp/web.conf webapp:/etc/web.conf 

SRC_PATH DEST_PATH

to copy container to host do opposite

PUBLISHING PORTS

docker run -p 80:5000 kodekloud/simple-webapp

all traffic on host at port 80 will get routed to port 5000 on the container


if you run the docker port mapping by default it is accesible on all the host interfaces

To limit that we specify the IP address with the port option:

docker run -p 192.168.1.5:8000:5000 kodekloud/simple-webapp

or you can do this

docker run -p 5000 kodekloud/simple-webapp 
this will publish to a random port on the host

it will be in the ephemeral port range => 32768 - 60999

cat /proc/sys/net/ipv4/ip_local_port_range
32768 60999


or run

docker run -P kodekloud/simple-webapp

Dockerfile

FROM ubuntu:16.04
RUN apt-get update && apt-get install -y python python-pip
RUN pip install flask
COPY app.py /opt/
ENTRYPOINT flask run
EXPOSE 5000

in the above case wi -P it will expose the pod on port 5000 in the dockerfile

you can expose additional ports on top of those in the dockerfile by using the --expose arg

docker run -P --expose=8000 kodekloud/simple-webapp

docker inspect kodekloud/simple-webapp

"ExposedPorts": {
   "5000/tcp": {},
   "8080/tcp": {}
},

docker relies on the kernel's IP Tables

DOCKER creates its own chain

DOCKER-USER DOCKER

iptables -t nat -S DOCKER


--rm (lookup why you would use this when creating a container)


docker system events --since 60m

docker container update --restart always httpd














